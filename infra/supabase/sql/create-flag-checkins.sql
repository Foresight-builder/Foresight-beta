-- Create flag_checkins table
CREATE TABLE IF NOT EXISTS public.flag_checkins (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  flag_id BIGINT NOT NULL REFERENCES public.flags(id) ON DELETE CASCADE,
  user_id TEXT NOT NULL,
  note TEXT,
  image_url TEXT,
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Add indexes
CREATE INDEX IF NOT EXISTS flag_checkins_flag_id_idx ON public.flag_checkins (flag_id);
CREATE INDEX IF NOT EXISTS flag_checkins_user_id_idx ON public.flag_checkins (user_id);
CREATE INDEX IF NOT EXISTS flag_checkins_created_at_idx ON public.flag_checkins (created_at);

-- Enable RLS
ALTER TABLE public.flag_checkins ENABLE ROW LEVEL SECURITY;

-- Policies
-- 1. Allow read for all authenticated users (or adjust as needed)
CREATE POLICY "flag_checkins_select_all" ON public.flag_checkins FOR SELECT USING (true);

-- 2. Allow insert for authenticated users (API handles ownership check, but RLS provides backup)
--    Actually, we can allow insert if user_id matches auth.uid(), OR rely on Service Role in API.
--    Since we use Service Role API for checkins, RLS for insert is less critical for the API, 
--    but good for security if we ever switch to client-side insert.
CREATE POLICY "flag_checkins_insert_own" ON public.flag_checkins FOR INSERT TO authenticated WITH CHECK (true);

-- Realtime
DO $$
BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM pg_publication_tables WHERE pubname = 'supabase_realtime' AND schemaname = 'public' AND tablename = 'flag_checkins'
  ) THEN
    ALTER PUBLICATION supabase_realtime ADD TABLE public.flag_checkins;
  END IF;
END $$;
